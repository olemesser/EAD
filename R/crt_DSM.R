#' @title Create a domain dependency matrix (DSM)
#' @description Creates a \code{N_el} x \code{N_el}  domain dependency matrix (DSM) based on different methods.
#' @param N_el Number of rows and columns for the DSM.
#' @param method A character specifying the method used for DSM generation. The following methods are available:
#' \describe{
#'   \item{DNS}{Generates a DSM by sampling random matrices to achieve a given density. Only  \code{PARAM$DNS} is needed}
#'   \item{modular}{Generates a DSM using two conditions. The procedure tries to achieve a certain density specified by \code{PARAM$DNS} and, second,
#'   tries to create a certain distribution for the off-diagonal elements which is specified via \code{PARAM$modular}. Low values of \code{PARAM$modular} indicate a random distribution while high values indicate that values are more clustered around the DSM main diagonal.
#'   The latter represents a strictly modular design with block matrices.}
#'   \item{bus}{}
#'   \item{bus-modular}{Runs \code{method = 'modular'} and \code{method = 'bus'} separately and than samples a final DSM via an element wise sampling of the DSMs generated by those two methods.
#'   Requires to define \code{PARAM$bus_weight}.}
#' }
#' @param PARAM A named list object with the following entries:
#' \describe{
#'   \item{DNS}{Density for the matrix. Must be between \code{0 <= DNS <= 1}. Mandatory for all sampling methods.}
#'   \item{modular}{A value which specifies the importance of modularity when choosing \code{method = 'modular'}.}
#'   \item{power}{The power law distribution coefficient. Passed to \link[igraph]{sample_pa}. Only relevant when choosing \code{method = 'bus'}.}
#'   \item{bus_weight}{A numeric with \code{0<= bus_weight <= 1}. Defines the sampling probability of the bus design.
#'   If \code{bus_weight = 1} the resulting matrix is identical to the bus matrix. If \code{bus_weight = 0} the resulting matrix is identical to the modular matrix.}
#' }
#' @param upper_Bound Integer, default \code{upper_Bound=20}, specifies the maximum number in the DMM if \code{binary=FALSE}
#' @param DENS A numeric value specifying the density within the DSM. This is an alternative method to generate the DSM.
#' @param forced A numeric vector containing indices of elements which cannot be zero since otherwise a invalid design is created later on.
#' @return A list object containing the product mix. This list consists of:
#' \describe{
#'   \item{DSM}{The created DSM}
#'   \item{measures}{A list of measures for the given DSM. The measures are: \link[EAD]{measure_DENS}, \link[EAD]{measure_structuralcomplexity},
#'   \link[EAD]{measure_modularity}, \link[EAD]{measure_neumannEntropy}, \link[EAD]{measure_MCC}, \link[EAD]{measure_HVM}, \link[EAD]{measure_HIC}}
#' }
#' @examples
#' set.seed(1234)
#' ## creating a random DSM ##
#' crt_DSM(N_el = 7,
#'         PARAM = list(DNS=0.1),
#'         method = 'DNS',
#'         upper_Bound = 1)
#'
#' ## creating a strictly modular DSM ##
#' crt_DSM(N_el = 7,
#'         PARAM = list(DNS=0.2,
#'                      modular = 1),
#'         method = 'modular',
#'         upper_Bound = 1)
#'
#' ## creating a bus DSM ##
#' crt_DSM(N_el = 7,
#'         PARAM = list(DNS = 0.2,
#'                      power = 1),
#'         method = 'bus',
#'         upper_Bound = 1)
crt_DSM<-function(N_el,
                  method=c('DNS','modular','bus','bus-modular'),
                  PARAM=list(DNS = 0.1,
                             modular = NULL,
                             power = NULL,
                             bus_weight = 0.5),
                  upper_Bound=5,
                  forced=NULL){

  #### Input Testing ####
  # set.seed(12)
  # N_el<-30
  # upper_Bound<-1
  # PARAM=list(DNS=0.1,
  #            modular=0,
  #            power = 0,
  #            bus_weight = 0)
  # forced <- NULL
  # method<-'bus-modular'
  # P_src<-expand.grid(list(c(0,1),
  #                  c(0,1),
  #                  c(0,1),
  #                  c(0,1)))
  # P_src<-as.matrix(P_src)
  # DMM<-crt_DMM(4,N_el,method='SDC',
  #              DMM_PAR=0.1,
  #              upper_Bound=1,
  #              allowZero = T)$DMM
  # forced<-which(colSums(DMM)==0)
  # P_tgt <- P_src %*% ((DMM %*% DSM) + DMM)
  # measure_DENS(P_src)
  # measure_DENS(P_tgt)
  #### END Input for Testing ####

  if(length(forced)==0) forced<-NULL

  ## number of steps after which the density is increased by step_width
  max_steps<-20
  step_width<-0.01
  cnt<-0
  if(method=="DNS"){
    repeat{
      DSM<-matrix(sample(c(0,1),N_el^2,prob = c(1-PARAM$DNS,PARAM$DNS),replace = T),nrow = N_el,ncol = N_el)
      diag(DSM)<-0
      cnt <- cnt+1
      if(check_DSMValidity(DSM,forced = forced)){
        if(!is.null(forced)) DSM[forced,]<-0
        break
      }else if(cnt>=max_steps){
        PARAM$DNS <- PARAM$DNS + 0.01
        cnt<-0
      }
    }
  }else if(method == 'modular' | method == 'bus-modular'){
    repeat{
      DSM<-crt_DSMmod(N_el = N_el,
                      DNS = PARAM$DNS,
                      modular = PARAM$modular)
      diag(DSM)<-0
      cnt <- cnt+1
      if(check_DSMValidity(DSM,forced = forced)){
        if(!is.null(forced)) DSM[forced,]<-0
        break
      }else if(cnt>=max_steps){
        PARAM$DNS <- PARAM$DNS + 0.01
        cnt<-0
      }
    }
  }else if(method == 'bus'){
    DSM <- crt_DSM_bus(N_el,PARAM$DNS,PARAM$power)
  }else{
    stop("You choose an invalid method for DSM generation. Available choices are: 'DNS', 'modular', 'bus'.")
  }

  if(method == 'bus-modular'){
    DSM_bus <- crt_DSM_bus(N_el,PARAM$DNS,PARAM$power)
    DSM_final <- matrix(0,nrow = N_el, ncol = N_el)
    for(i in 1:N_el){
      for(j in 1:N_el){
        DSM_final[i,j] <- sample(c(DSM_bus[i,j],DSM[i,j]),1,prob = c(PARAM$bus_weight,1 - PARAM$bus_weight))
      }
    }
    DSM <- DSM_final
    # measure_DENS(DSM)
    # g <- graph_from_adjacency_matrix(DSM,mode = 'undirected')
    # DSM_new <- adjust_graph_dens(g = g,
    #                              DSM = DSM,
    #                              DNS = PARAM$DNS)
    # measure_DENS(DSM_new)
  }

  DSM_bin<-DSM
  DSM[DSM>0]<-sample(1:upper_Bound,size=sum(DSM_bin>0),replace = T)

  measures<-list(DENS_DSM=measure_DENS(DSM),
                 SC=measure_structuralcomplexity(DSM),
                 Q=measure_modularity(DSM),
                 NE=measure_neumannEntropy(DSM),
                 MCC_n=measure_MCC(DSM,norm=T),
                 HVM_n=measure_HVM(DSM,norm=T),
                 HIC_n=measure_HIC(DSM,norm=T),
                 MCC=measure_MCC(DSM,norm = F),
                 HVM=measure_HVM(DSM,norm = F),
                 HIC=measure_HIC(DSM,norm = F))

  output<-list(DSM = DSM,
               measures = measures)
  return(output)
}



crt_DSMmod<-function(N_el,DNS,modular=0){
  require(Matrix)
  #### INput for testing ####
  # N_el<-10
  # modular<-0
  # DNS<-0.2
  #### END input testing ####

  size_bM<-rand_vect(3,N_el)
  bm<-lapply(size_bM,function(x){
    matrix(sample(0:1,x^2,replace = T,prob = c(1-modular,modular)),ncol=x)
  })
  DSM<-bdiag(bm)
  DSM<-as.matrix(DSM)
  DNS_is<-measure_DENS(DSM)
  if(DNS_is>DNS){
    el_rmv<-sum(DSM)-ceiling(NROW(DSM)^2*DNS)
    DSM[DSM>0][sample(1:sum(DSM>0),el_rmv)]<-0
  }else if(DNS_is<DNS){
    el_add<-ceiling(NROW(DSM)^2*DNS)-sum(DSM)
    DSM[DSM==0][sample(1:sum(DSM==0),el_add)]<-1
  }
  return(DSM)
}

crt_DSM_bus <- function(N_el,DNS,power){
  require(igraph)
  g <- sample_pa(n = N_el,
                 power = power,
                 directed = F)
  DSM <- as.matrix(as_adjacency_matrix(g))
  DSM <- adjust_graph_dens(g,DSM,DNS)
  return(DSM)
}


adjust_graph_dens <- function(g,DSM,DNS){
  run <- F
  while(measure_DENS(DSM) > DNS){
    g <- delete_edges(g,sample(E(g),1))
    DSM<-as.matrix(as_adjacency_matrix(g))
    run <- T
  }

  while(measure_DENS(DSM) < DNS & run == F){
    empty_edges <- which(makeMatrixsymmetric(DSM) == 0,arr.ind = T)
    empty_edges <- empty_edges[empty_edges[,1] != empty_edges[,2],]
    empty_edges <- empty_edges[sample(1:NROW(empty_edges),1),]
    g <- g %>% add_edges(as.vector(empty_edges))
    DSM<-as.matrix(as_adjacency_matrix(g))
    run <- T
  }
  return(DSM)
}


check_DSMValidity<-function(DSM,forced=NULL){
  if(!is.null(forced)){
    return(all(colSums(DSM[-forced,forced,drop=F])>0))
  }else{
    return(TRUE)
  }
}
